# Conversational AI: Building Intelligent Chatbots Across Platforms - 06: Instagram DM Chatbot for Lead Capture

## Introduction: Why Instagram DMs are a Goldmine for Lead Capture

Instagram is no longer just a photo-sharing app; it's a full-fledged engagement platform where brands, creators, and customers interact in real time. With over 2 billion monthly active users and strong adoption among Gen Z and millennials, Instagram has quietly become a business-critical messaging channel. More importantly, **Instagram Direct Messages (DMs)** have emerged as a prime touchpoint for lead capture.

### üèõÔ∏è The Case for Lead Generation on Instagram DMs

Traditional lead forms on landing pages are becoming stale. Users prefer conversational, instant interactions‚Äîespecially on platforms where they already spend time. Instagram DMs allow businesses to:

- Respond instantly to product inquiries
- Collect user details in a conversational format
- Qualify leads through back-and-forth Q\&A
- Trigger automation workflows based on user responses

This makes DMs a great fit for:

- Influencers promoting paid offers
- E-commerce brands capturing product interest
- Service businesses booking appointments
- Coaches and consultants qualifying prospects

### ‚ú® What Makes Instagram Bots Unique?

Unlike a website or even WhatsApp chatbot, an Instagram DM bot has:

- **Social Context:** Users often message after seeing a post, reel, or story.
- **User Handles:** Instagram usernames are attached to every DM.
- **Visual-first Messaging:** Emojis, media, and quick replies make the UX rich.
- **API Nuances:** Meta tightly controls access; bots must follow exact webhook flows and permission rules.

### üöÄ The Engagement Opportunity

The average Instagram user is far more likely to open and respond to a DM than an email or push notification. In fact:

> üîπ _Instagram messages have an 80-90% open rate and 30-40% reply rate ‚Äî significantly higher than traditional email._

This makes Instagram bots especially effective for top-of-funnel engagement and initial lead qualification. Once you capture the lead's name, email, and interest, you can pipe that into your CRM or sales system and follow up outside Instagram.

### ü§î Why Automate Instead of Replying Manually?

If you're a small business or creator, replying manually is manageable ‚Äî until it isn't. As DMs scale, manual responses:

- Become inconsistent and error-prone
- Delay response times (missed leads!)
- Can‚Äôt scale beyond a single person

A bot ensures:

- **24/7 availability**
- **Structured data collection** (name, email, interest)
- **Lead routing** to your CRM or Google Sheets
- **Personalized replies** at scale

### üöß What We'll Build

In this hands-on guide, we'll build an Instagram DM bot that:

- Replies to incoming messages automatically
- Walks users through a mini lead capture funnel
- Validates inputs (e.g., checks if email is valid)
- Stores leads in a Supabase table

By the end, you'll have:

- A Node.js + Express server running your DM bot
- Webhook integration with Meta's Instagram API
- A working conversation flow that captures leads

Let's dive in ‚Äî starting with how Meta's API works under the hood ‚ú®

## Meta‚Äôs Messaging API: Understanding the Tech Behind Instagram DM Bots

Before we write a single line of code, it's crucial to understand how Meta's ecosystem works when it comes to enabling Instagram messaging for bots. Unlike most messaging platforms, Meta enforces strict permissions, account configurations, and API contracts. Let's break it all down ü§∑‚Äç‚ôÇÔ∏è

### üìÇ Account Requirements: What You Need to Start

To interact with Instagram DMs via the API, Meta requires a few things to be properly set up:

#### 1. Facebook Developer Account

- Go to [developers.facebook.com](https://developers.facebook.com/) and create a developer account.

#### 2. Facebook App

- Create a new app of type **Business**. This gives access to Instagram Graph and Messaging APIs.

#### 3. Instagram Business Account

- Your Instagram account must be a **Professional (Business)** account.
- It must be connected to a Facebook Page.

#### 4. Facebook Page

- The connected Page acts as the container for the Instagram account.

#### 5. App Permissions

- Request and enable:

  - `pages_show_list`
  - `instagram_basic`
  - `instagram_manage_messages`
  - `pages_messaging`

#### 6. Webhook Configuration

- Set up a webhook to receive message events.
- Subscribe to the `messages` and `messaging_postbacks` fields for both Page and Instagram.

### üìä API Flow: How the Instagram Messaging Lifecycle Works

Understanding the message lifecycle helps you design proper flows:

1. **User Sends Message**

   - A user DMs your business on Instagram.

2. **Meta Webhook Triggers**

   - Your webhook receives an HTTP POST event.

3. **Server Processes It**

   - Your code parses the message and checks if it‚Äôs a new lead.

4. **Bot Sends a Reply**

   - You call the Instagram Messaging API to reply using the Page access token.

### üîë Access Tokens and Authentication

You‚Äôll use a **Page Access Token** to authenticate API calls. During development:

- Generate a **User Access Token** with `pages_show_list` permission
- Use Graph API Explorer to request a **long-lived Page Token**

Keep these tokens in `.env` files:

```env
PAGE_ACCESS_TOKEN=your_page_access_token_here
VERIFY_TOKEN=your_custom_verify_token
```

Use the Page Token when calling the Messaging API:

```bash
curl -X POST "https://graph.facebook.com/v19.0/me/messages" \
  -H "Content-Type: application/json" \
  -d '{
    "recipient": {"id": "<PSID>"},
    "message": {"text": "Hello from your bot!"},
    "messaging_type": "RESPONSE",
    "access_token": "<PAGE_ACCESS_TOKEN>"
  }'
```

### üõ†Ô∏è Webhook Event Format (Instagram Message)

Here‚Äôs what a typical webhook payload looks like when someone DMs your Instagram:

```json
{
  "object": "instagram",
  "entry": [
    {
      "id": "<page-id>",
      "time": 1698888888,
      "messaging": [
        {
          "sender": { "id": "<user-psid>" },
          "recipient": { "id": "<page-id>" },
          "timestamp": 1698888888,
          "message": {
            "mid": "<message-id>",
            "text": "Hi, I‚Äôm interested!"
          }
        }
      ]
    }
  ]
}
```

Your server needs to:

- Verify the webhook signature
- Parse this payload
- Decide how to respond

### üìñ API Docs to Bookmark

Keep these Meta docs handy as we build:

- [Instagram Messaging API Overview](https://developers.facebook.com/docs/instagram-api/guides/messaging/)
- [Webhook Reference](https://developers.facebook.com/docs/graph-api/webhooks/)
- [Graph API Explorer](https://developers.facebook.com/tools/explorer/)

Now that we understand how Meta's Instagram Messaging API works, we're ready to start building our backend!

Next up: **setting up the Node.js + Express bot server** ‚ú®

## Project Setup: Building the Bot Server with Node.js + Express

With Meta's platform basics in place, it‚Äôs time to get our hands dirty and start building the actual Instagram DM bot backend ‚ú®

We‚Äôll use **Node.js + Express** as the foundation for our server. This will handle:

- Verifying Meta‚Äôs webhook
- Receiving and responding to messages
- Managing lead state and flow

### üîÑ Step 1: Initialize the Project

Create a new project folder:

```bash
mkdir insta-lead-bot && cd insta-lead-bot
npm init -y
```

### üìÅ Step 2: Install Dependencies

We‚Äôll need the following packages:

```bash
npm install express axios dotenv body-parser
```

**Breakdown:**

- `express`: Core web framework
- `axios`: For outbound API calls to Meta
- `dotenv`: Loads env vars from `.env`
- `body-parser`: Parses incoming webhook JSON

### üîß Step 3: Project Structure

Let‚Äôs organize our files for maintainability:

```structure
insta-lead-bot/
‚îú‚îÄ‚îÄ controllers/
‚îÇ   ‚îî‚îÄ‚îÄ messageController.js
‚îú‚îÄ‚îÄ routes/
‚îÇ   ‚îî‚îÄ‚îÄ webhook.js
‚îú‚îÄ‚îÄ services/
‚îÇ   ‚îî‚îÄ‚îÄ instagramService.js
‚îú‚îÄ‚îÄ .env
‚îú‚îÄ‚îÄ app.js
‚îî‚îÄ‚îÄ server.js
```

This will help separate logic by responsibility.

### üëÅ‚Äçüó®Ô∏è Step 4: Create the Entry Point

`server.js` will launch the app:

```js
// server.js
const app = require("./app");
const PORT = process.env.PORT || 3000;

app.listen(PORT, () => {
  console.log(`Bot server running on port ${PORT}`);
});
```

### ‚öñÔ∏è Step 5: Setup Express in `app.js`

```js
// app.js
const express = require("express");
const bodyParser = require("body-parser");
const dotenv = require("dotenv");
const webhookRoutes = require("./routes/webhook");

dotenv.config();

const app = express();
app.use(bodyParser.json());
app.use("/webhook", webhookRoutes);

module.exports = app;
```

### üîí Step 6: Create `.env` File

```env
PAGE_ACCESS_TOKEN=your_meta_page_token
VERIFY_TOKEN=your_custom_verify_token
```

This keeps your secrets out of version control.

### üîç Step 7: Webhook Route

Create `routes/webhook.js`:

```js
const express = require("express");
const router = express.Router();
const messageController = require("../controllers/messageController");

router.get("/", messageController.verifyWebhook);
router.post("/", messageController.handleMessage);

module.exports = router;
```

### ü§ñ Step 8: Webhook Controller Stub

Create `controllers/messageController.js`:

```js
exports.verifyWebhook = (req, res) => {
  const VERIFY_TOKEN = process.env.VERIFY_TOKEN;
  const mode = req.query["hub.mode"];
  const token = req.query["hub.verify_token"];
  const challenge = req.query["hub.challenge"];

  if (mode && token === VERIFY_TOKEN) {
    console.log("Webhook verified");
    return res.status(200).send(challenge);
  } else {
    return res.sendStatus(403);
  }
};

exports.handleMessage = (req, res) => {
  console.log("Incoming webhook:", JSON.stringify(req.body, null, 2));
  res.sendStatus(200); // Acknowledge receipt to Meta
};
```

This code handles webhook verification and logs incoming payloads.

With this setup, your server is ready to receive Instagram DMs and respond to Meta‚Äôs webhook challenge.

Next up: **Handling Webhook Verification + Message Reception** ‚úÖ

## Webhook Verification + Receiving Instagram Messages

Now that our server is running and the routes are in place, the next step is to handle **Meta's webhook verification process** and start parsing real-time Instagram messages ‚úÖ

### üìÉ Step 1: Understanding Meta's Webhook Verification

When you register your webhook URL in the Meta Developer Console, Meta sends a `GET` request with three query parameters:

- `hub.mode`
- `hub.verify_token`
- `hub.challenge`

You need to:

- Check if the `verify_token` matches what you set
- Respond with the `challenge` string if it does

This verifies that you control the endpoint ‚Äî a required step before Meta starts sending real message events.

We already wrote the verification logic in our controller:

```js
exports.verifyWebhook = (req, res) => {
  const VERIFY_TOKEN = process.env.VERIFY_TOKEN;
  const mode = req.query["hub.mode"];
  const token = req.query["hub.verify_token"];
  const challenge = req.query["hub.challenge"];

  if (mode && token === VERIFY_TOKEN) {
    console.log("Webhook verified");
    return res.status(200).send(challenge);
  } else {
    return res.sendStatus(403);
  }
};
```

Test this with:

```bash
curl -X GET 'http://localhost:3000/webhook?hub.mode=subscribe&hub.verify_token=your_custom_verify_token&hub.challenge=1234'
```

### üì¢ Step 2: Registering the Webhook with Meta

In the [Meta Developer Console](https://developers.facebook.com/apps/):

1. Go to your app > **Webhooks** section
2. Choose **Instagram** or **Page** (based on setup)
3. Enter your webhook URL, e.g. `https://yourdomain.com/webhook`
4. Enter your `VERIFY_TOKEN`
5. Subscribe to `messages`, `messaging_postbacks`

You‚Äôll see a success message if verification worked!

### üìà Step 3: Receiving Instagram DMs

When a user sends a DM to your Instagram account, Meta sends a `POST` request to your webhook endpoint:

Here's how we already log that:

```js
exports.handleMessage = (req, res) => {
  console.log("Incoming webhook:", JSON.stringify(req.body, null, 2));
  res.sendStatus(200);
};
```

Example webhook payload:

```json
{
  "object": "instagram",
  "entry": [
    {
      "id": "<page-id>",
      "time": 1698888888,
      "messaging": [
        {
          "sender": { "id": "<user-id>" },
          "recipient": { "id": "<page-id>" },
          "timestamp": 1698888888,
          "message": {
            "mid": "<msg-id>",
            "text": "Hi! I'm interested."
          }
        }
      ]
    }
  ]
}
```

You can extract the relevant info like this:

```js
exports.handleMessage = (req, res) => {
  const body = req.body;

  if (body.object === "instagram") {
    body.entry.forEach((entry) => {
      const event = entry.messaging[0];
      const senderId = event.sender.id;
      const message = event.message.text;

      console.log(`Message from ${senderId}: ${message}`);
      // Later: Call your response function here
    });
  }
  res.sendStatus(200);
};
```

### ‚úâÔ∏è Testing Message Events

Use a real Instagram account (with test user access) to DM the connected business profile.

You can also simulate via `curl` or Postman (for raw webhook testing).

At this point:

- ‚úÖ Your webhook URL is verified
- üîé You can inspect incoming DMs

Next up: **Sending Replies to Instagram Messages using Meta‚Äôs API** üöÄ

## Sending Messages Back: The DM Reply Handler

Receiving DMs is only half the job. To complete the loop, your bot needs to **reply to messages using the Instagram Messaging API.** Let's now implement the response logic so our bot can interact with users in real time üöÄ

### üîÑ The Send Message Flow

When a DM arrives:

1. Your webhook receives and parses the message
2. Your server extracts the `sender.id`
3. You make a `POST` request to Meta's Graph API
4. Meta delivers your message to the user

### üìù Meta Messaging API Endpoint

```url
POST https://graph.facebook.com/v19.0/me/messages?access_token=<PAGE_ACCESS_TOKEN>
```

This API requires:

- `recipient.id` (sender PSID from webhook)
- `message.text` (or structured message payload)

### üõ†Ô∏è Create Instagram Service

In `services/instagramService.js`, add this:

```js
const axios = require("axios");

const PAGE_ACCESS_TOKEN = process.env.PAGE_ACCESS_TOKEN;

async function sendTextMessage(recipientId, text) {
  const url = `https://graph.facebook.com/v19.0/me/messages?access_token=${PAGE_ACCESS_TOKEN}`;

  const payload = {
    recipient: { id: recipientId },
    message: { text: text },
    messaging_type: "RESPONSE",
  };

  try {
    const res = await axios.post(url, payload);
    console.log("Message sent:", res.data);
  } catch (err) {
    console.error("Error sending message:", err.response?.data || err.message);
  }
}

module.exports = {
  sendTextMessage,
};
```

This is your core DM response function.

### ü§ñ Use It in the Controller

Update `controllers/messageController.js` to use the reply logic:

```js
const { sendTextMessage } = require("../services/instagramService");

exports.handleMessage = async (req, res) => {
  const body = req.body;

  if (body.object === "instagram") {
    for (const entry of body.entry) {
      const event = entry.messaging[0];
      const senderId = event.sender.id;
      const message = event.message?.text;

      if (message) {
        console.log(`User says: ${message}`);
        await sendTextMessage(
          senderId,
          "Hey! Thanks for messaging us. How can I help you today? üòä"
        );
      }
    }
  }
  res.sendStatus(200);
};
```

This sends a simple text reply for any incoming message.

### üìû Optional: Typing Indicators + Seen Status

Instagram also allows:

- `sender_action: typing_on`
- `sender_action: mark_seen`

Add these to show user feedback:

```js
async function markSeen(recipientId) {
  const url = `https://graph.facebook.com/v19.0/me/messages?access_token=${PAGE_ACCESS_TOKEN}`;

  await axios.post(url, {
    recipient: { id: recipientId },
    sender_action: "mark_seen",
  });
}

async function showTyping(recipientId) {
  const url = `https://graph.facebook.com/v19.0/me/messages?access_token=${PAGE_ACCESS_TOKEN}`;

  await axios.post(url, {
    recipient: { id: recipientId },
    sender_action: "typing_on",
  });
}

module.exports = {
  sendTextMessage,
  markSeen,
  showTyping,
};
```

Then call these before sending a reply for a more human-like UX.

### üöß Debugging Tips

- Check Meta logs for failed API requests
- Make sure `PAGE_ACCESS_TOKEN` is current and has permissions
- Log full error responses from Axios

At this point, your bot can receive and **reply to Instagram DMs** automatically ‚ú®

Next: Let‚Äôs build a **guided lead capture flow** that collects the user's name, email, and interest üìä

## Building the Lead Capture Flow: Name, Email, and Interest

With message handling and replies in place, it‚Äôs time to build the heart of our bot: a **structured, conversational lead capture flow**. Our goal is to collect three pieces of information:

- User's **Name**
- **Email Address** (validated)
- Area of **Interest** (optional free text)

We‚Äôll maintain conversational context using a simple session-based memory and validate inputs step-by-step ‚úèÔ∏è

### üß† State Management: In-Memory Session Store

To manage conversation state, we‚Äôll track user progress in a simple object (or Redis in production).

Create `sessionStore.js`:

```js
const sessions = {};

function getSession(userId) {
  if (!sessions[userId]) {
    sessions[userId] = { step: 0, data: {} };
  }
  return sessions[userId];
}

function clearSession(userId) {
  delete sessions[userId];
}

module.exports = { getSession, clearSession };
```

This will store:

- `step`: Current conversation step
- `data`: Collected name/email/interest

### üåê Update Controller Logic

Edit `controllers/messageController.js` to support flow logic:

```js
const { sendTextMessage } = require("../services/instagramService");
const { getSession, clearSession } = require("../sessionStore");
const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;

exports.handleMessage = async (req, res) => {
  const body = req.body;

  if (body.object === "instagram") {
    for (const entry of body.entry) {
      const event = entry.messaging[0];
      const senderId = event.sender.id;
      const message = event.message?.text;

      if (message) {
        const session = getSession(senderId);

        switch (session.step) {
          case 0:
            await sendTextMessage(senderId, "Hey! üëã What's your name?");
            session.step = 1;
            break;

          case 1:
            session.data.name = message;
            await sendTextMessage(
              senderId,
              `Nice to meet you, ${message}! What's your email? ‚úâÔ∏è`
            );
            session.step = 2;
            break;

          case 2:
            if (!emailRegex.test(message)) {
              await sendTextMessage(
                senderId,
                "Hmm, that doesn't look like a valid email. Try again ‚úçÔ∏è"
              );
            } else {
              session.data.email = message;
              await sendTextMessage(
                senderId,
                "Got it! Lastly, what are you interested in? üí°"
              );
              session.step = 3;
            }
            break;

          case 3:
            session.data.interest = message;
            await sendTextMessage(
              senderId,
              "Awesome! Thanks for sharing. We'll be in touch soon. üöÄ"
            );
            console.log("Captured lead:", session.data);
            clearSession(senderId);
            break;
        }
      }
    }
  }
  res.sendStatus(200);
};
```

### üîé What This Flow Does

- Initiates only when a user sends a message
- Asks for each field sequentially
- Validates email using regex
- Logs full lead data once captured

You can extend this to:

- Send data to Supabase (next section)
- Add buttons or quick replies for predefined interest topics
- Handle restarts and `/reset` commands

### ‚ÑπÔ∏è UX Notes

Keep your messages friendly and conversational. Use emojis and confirmations to show progress.

E.g., instead of:

> "Email?"

Say:

> "Cool! Now I just need your email so we can reach you later. ‚úâÔ∏è"

Next up: We‚Äôll **store the collected lead data in Supabase** so it doesn‚Äôt vanish when the server restarts üìÇ

## Storing Leads: Connecting to Supabase (or Firebase)

Capturing user data in-memory is fine for local testing, but in production we need to **persist lead data** to a proper database. For this, we‚Äôll use **Supabase** ‚Äî a serverless PostgreSQL platform with a slick API and dashboard that integrates perfectly with JavaScript.

### üìÇ Why Supabase?

- Free and generous tier for small projects
- RESTful + real-time + SQL access
- Easy setup and JavaScript SDK
- Auth, storage, and other tools if needed later

### üì¶ Step 1: Create a Supabase Project

1. Go to [https://supabase.com](https://supabase.com)
2. Sign in with GitHub and create a new project
3. Name it `instagram-lead-bot`
4. Set a strong password and choose a region

Once provisioned:

- Copy the **project URL** and **anon API key** from Project Settings > API

### üîç Step 2: Define the Leads Table

In the **Table Editor**, create a new table called `leads`:

| Column     | Type        | Notes                      |
| ---------- | ----------- | -------------------------- |
| id         | uuid        | Primary key (default UUID) |
| name       | text        | Name from the DM flow      |
| email      | text        | Validated email address    |
| interest   | text        | Freeform user input        |
| source     | text        | Set to 'instagram'         |
| created_at | timestamptz | Default: now()             |

Enable **Row Level Security**, then add a policy:

```sql
CREATE POLICY "Allow all insert" ON public.leads
FOR INSERT WITH CHECK (true);
```

### üéì Step 3: Install Supabase JS SDK

```bash
npm install @supabase/supabase-js
```

### üîß Step 4: Create Supabase Service

Create `services/supabaseService.js`:

```js
const { createClient } = require("@supabase/supabase-js");

const supabase = createClient(
  process.env.SUPABASE_URL,
  process.env.SUPABASE_ANON_KEY
);

async function storeLead({ name, email, interest }) {
  const { data, error } = await supabase
    .from("leads")
    .insert([{ name, email, interest, source: "instagram" }]);

  if (error) {
    console.error("Error inserting lead:", error);
  } else {
    console.log("Lead stored successfully:", data);
  }
}

module.exports = { storeLead };
```

### üîê Step 5: Add to `.env`

```env
SUPABASE_URL=https://xyzcompany.supabase.co
SUPABASE_ANON_KEY=your_anon_key_here
```

### üìù Step 6: Plug Into Flow

Update `messageController.js` to import and call `storeLead`:

```js
const { storeLead } = require('../services/supabaseService');

...
case 3:
  session.data.interest = message;
  await sendTextMessage(senderId, "Awesome! Thanks for sharing. We'll be in touch soon. üöÄ");
  await storeLead(session.data);
  clearSession(senderId);
  break;
```

### üß∞ Production Tips

- Sanitize input if handling raw text
- Use Supabase Auth for restricted access later
- Consider rate limiting to avoid spam/flooding

Now your bot persists leads to a real-time PostgreSQL database via Supabase.

Next: let‚Äôs **deploy the bot server and connect it with Meta‚Äôs live webhook config** ‚ú®
